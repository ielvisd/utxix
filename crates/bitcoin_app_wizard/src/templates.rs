use crate::wizard_modal::{Framework, Template};

// ============================================================================
// NOTE: No backend required - Yours Wallet is a browser extension
// ============================================================================

pub const ENV_EXAMPLE: &str = r#"# Blockchain network (testnet or mainnet)
VITE_BSV_NETWORK=testnet

# Contract artifact path (generated by scrypt-cli compile)
VITE_ARTIFACT_PATH=/artifacts/contracts/Contract.scrypt.json
"#;

// ============================================================================
// CONTRACT TEMPLATES
// ============================================================================

pub fn contract_filename(template: Template) -> &'static str {
    match template {
        Template::HelloWorld => "HelloWorld.scrypt.ts",
        Template::Counter => "Counter.scrypt.ts",
        Template::TicTacToe => "TicTacToe.scrypt.ts",
        Template::Auction => "Auction.scrypt.ts",
        Template::Custom => "Contract.scrypt.ts",
    }
}

pub fn contract_source(template: Template, description: Option<&str>) -> String {
    match template {
        Template::HelloWorld => HELLOWORLD_CONTRACT.to_string(),
        Template::Counter => COUNTER_CONTRACT.to_string(),
        Template::TicTacToe => TICTACTOE_CONTRACT.to_string(),
        Template::Auction => AUCTION_CONTRACT.to_string(),
        Template::Custom => generate_custom_contract(description.unwrap_or("Custom Bitcoin app")),
    }
}

pub const HELLOWORLD_CONTRACT: &str = r#"import {
  SmartContract,
  method,
  prop,
  ByteString,
  sha256,
  assert,
} from "scrypt-ts";

export class HelloWorld extends SmartContract {
  @prop()
  hash: ByteString;

  constructor(hash: ByteString) {
    super(...arguments);
    this.hash = hash;
  }

  @method()
  public unlock(message: ByteString) {
    assert(sha256(message) === this.hash, "Hash mismatch");
  }
}

export default HelloWorld;
"#;

pub const COUNTER_CONTRACT: &str = r#"import {
  SmartContract,
  method,
  prop,
  assert,
  hash256,
  SigHash,
} from "scrypt-ts";

export class Counter extends SmartContract {
  @prop(true)
  count: bigint;

  constructor(count: bigint) {
    super(...arguments);
    this.count = count;
  }

  @method(SigHash.ANYONECANPAY_SINGLE)
  public increment() {
    this.count++;

    const outputs = this.buildStateOutput(this.ctx.utxo.value);
    assert(hash256(outputs) === this.ctx.hashOutputs, "hashOutputs mismatch");
  }
}

export default Counter;
"#;

pub const TICTACTOE_CONTRACT: &str = r#"import {
  SmartContract,
  method,
  prop,
  FixedArray,
  assert,
  PubKey,
  PubKeyHash,
  Sig,
  hash256,
  hash160,
  SigHash,
  Utils,
  ByteString,
  toByteString,
} from "scrypt-ts";

/**
 * Tic-Tac-Toe Smart Contract
 * 
 * Board: 0 = empty, 1 = X, 2 = O
 * 
 * Uses ANYONECANPAY_SINGLE sighash:
 * - ANYONECANPAY: allows anyone to add inputs (for fees)
 * - SINGLE: only verifies output at index 0
 * 
 * Tx structure:
 * - Input 0: Contract UTXO
 * - Input 1+: Fee UTXOs (added by custom tx builder)
 * - Output 0: Next state or winner payout (verified by contract)
 * - Output 1+: Change (not verified)
 */
export class TicTacToe extends SmartContract {
  @prop(true)
  board: FixedArray<bigint, 9>;

  @prop(true)
  isXTurn: boolean;

  @prop()
  playerX: PubKey;

  @prop()
  playerO: PubKey;

  @prop()
  stake: bigint;

  constructor(playerX: PubKey, playerO: PubKey, stake: bigint) {
    super(...arguments);
    this.board = [0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n];
    this.isXTurn = true;
    this.playerX = playerX;
    this.playerO = playerO;
    this.stake = stake;
  }

  @method(SigHash.ANYONECANPAY_SINGLE)
  public move(position: bigint, sig: Sig) {
    const currentPlayer = this.isXTurn ? this.playerX : this.playerO;
    assert(this.checkSig(sig, currentPlayer), "Invalid signature");

    assert(position >= 0n && position < 9n, "Invalid position");
    assert(this.board[Number(position)] === 0n, "Position occupied");

    this.board[Number(position)] = this.isXTurn ? 1n : 2n;
    
    const winner = this.checkWinner();
    let outputs: ByteString = toByteString("");
    
    if (winner !== 0n) {
      // Game over - pay winner
      const winnerPubKey = winner === 1n ? this.playerX : this.playerO;
      const winnerPkh: PubKeyHash = hash160(winnerPubKey);
      outputs = Utils.buildPublicKeyHashOutput(winnerPkh, this.ctx.utxo.value);
    } else if (this.isBoardFull()) {
      // Draw - split pot (each gets half)
      const halfValue = this.ctx.utxo.value / 2n;
      const xPkh: PubKeyHash = hash160(this.playerX);
      outputs = Utils.buildPublicKeyHashOutput(xPkh, halfValue);
      // Note: Output 1 (playerO) built by frontend, not verified with SINGLE
    } else {
      // Game continues - update state
      this.isXTurn = !this.isXTurn;
      outputs = this.buildStateOutput(this.ctx.utxo.value);
    }
    
    assert(hash256(outputs) === this.ctx.hashOutputs, "outputs mismatch");
  }

  @method()
  isBoardFull(): boolean {
    let full = true;
    for (let i = 0; i < 9; i++) {
      if (this.board[i] === 0n) {
        full = false;
      }
    }
    return full;
  }

  @method()
  checkWinner(): bigint {
    // Winning combinations
    const lines: FixedArray<FixedArray<bigint, 3>, 8> = [
      [0n, 1n, 2n], [3n, 4n, 5n], [6n, 7n, 8n], // rows
      [0n, 3n, 6n], [1n, 4n, 7n], [2n, 5n, 8n], // cols
      [0n, 4n, 8n], [2n, 4n, 6n]                 // diagonals
    ];
    
    for (let i = 0; i < 8; i++) {
      const a = Number(lines[i][0]);
      const b = Number(lines[i][1]);
      const c = Number(lines[i][2]);
      if (this.board[a] !== 0n && 
          this.board[a] === this.board[b] && 
          this.board[a] === this.board[c]) {
        return this.board[a]; // 1 for X, 2 for O
      }
    }
    return 0n; // No winner
  }
}

export default TicTacToe;
"#;

pub const AUCTION_CONTRACT: &str = r#"import {
  SmartContract,
  method,
  prop,
  PubKey,
  PubKeyHash,
  Sig,
  assert,
  hash256,
  hash160,
  SigHash,
  Utils,
  ByteString,
} from "scrypt-ts";

/**
 * Auction Smart Contract
 * 
 * Uses ANYONECANPAY_SINGLE sighash:
 * - ANYONECANPAY: allows bidders to add their funding inputs
 * - SINGLE: only verifies output at index 0 (contract state or payout)
 * 
 * Flow:
 * 1. Auctioneer deploys with initial state
 * 2. Bidders call bid() with higher amounts
 * 3. Previous bidder gets refunded (output 1, not verified)
 * 4. After deadline, anyone can call close() to pay auctioneer
 */
export class Auction extends SmartContract {
  @prop()
  auctioneer: PubKey;

  @prop(true)
  highestBidder: PubKey;

  @prop(true)
  highestBid: bigint;

  @prop()
  auctionDeadline: bigint;

  constructor(auctioneer: PubKey, deadline: bigint) {
    super(...arguments);
    this.auctioneer = auctioneer;
    this.highestBidder = auctioneer;
    this.highestBid = 0n;
    this.auctionDeadline = deadline;
  }

  @method(SigHash.ANYONECANPAY_SINGLE)
  public bid(bidder: PubKey, bidAmount: bigint) {
    // Ensure auction is still active (before deadline)
    assert(this.ctx.locktime < this.auctionDeadline, "Auction ended");

    // Ensure bid is higher than current highest
    assert(bidAmount > this.highestBid, "Bid too low");

    // Store previous bidder for refund (built by frontend at output 1)
    const prevBidder = this.highestBidder;
    const prevBid = this.highestBid;

    // Update state
    this.highestBidder = bidder;
    this.highestBid = bidAmount;

    // Output 0: Updated contract state with new bid amount
    // Note: Frontend must also build output 1 with refund to prevBidder
    let outputs: ByteString = this.buildStateOutput(bidAmount);
    
    // If there was a previous bid, verify refund output exists
    // (With SINGLE, we only verify output 0, but we can check total outputs)
    if (prevBid > 0n) {
      // Frontend must add: Utils.buildPublicKeyHashOutput(hash160(prevBidder), prevBid)
      // as output 1 in the custom tx builder
    }
    
    assert(hash256(outputs) === this.ctx.hashOutputs, "outputs mismatch");
  }

  @method(SigHash.ANYONECANPAY_SINGLE)
  public close(sig: Sig) {
    // Only auctioneer can close
    assert(this.checkSig(sig, this.auctioneer), "Not auctioneer");

    // Ensure deadline has passed
    assert(this.ctx.locktime >= this.auctionDeadline, "Auction not ended");
    assert(this.ctx.sequence < 0xffffffffn, "nLocktime must be enabled");

    // Pay the winning bid to auctioneer
    const auctioneerPkh: PubKeyHash = hash160(this.auctioneer);
    const outputs = Utils.buildPublicKeyHashOutput(auctioneerPkh, this.highestBid);
    
    assert(hash256(outputs) === this.ctx.hashOutputs, "outputs mismatch");
  }

  @method(SigHash.ANYONECANPAY_SINGLE)
  public refund(sig: Sig) {
    // If no bids, auctioneer can reclaim deposit
    assert(this.checkSig(sig, this.auctioneer), "Not auctioneer");
    assert(this.highestBid === 0n, "Has bids");
    
    const auctioneerPkh: PubKeyHash = hash160(this.auctioneer);
    const outputs = Utils.buildPublicKeyHashOutput(auctioneerPkh, this.ctx.utxo.value);
    
    assert(hash256(outputs) === this.ctx.hashOutputs, "outputs mismatch");
  }
}

export default Auction;
"#;

pub fn generate_custom_contract(description: &str) -> String {
    format!(
        r#"import {{
  SmartContract,
  method,
  prop,
  assert,
  hash256,
  hash160,
  SigHash,
  PubKey,
  PubKeyHash,
  Sig,
  ByteString,
  toByteString,
  Utils,
}} from "scrypt-ts";

/**
 * Custom Bitcoin Smart Contract
 * 
 * Requirements from user:
 * {description}
 * 
 * KEY PATTERNS TO USE:
 * 
 * 1. SigHash.ANYONECANPAY_SINGLE for settlement methods:
 *    - ANYONECANPAY: allows adding fee inputs
 *    - SINGLE: only verifies output 0
 * 
 * 2. Output verification:
 *    const outputs = Utils.buildPublicKeyHashOutput(pkh, value);
 *    assert(hash256(outputs) === this.ctx.hashOutputs, "outputs mismatch");
 * 
 * 3. Commit-reveal pattern for hidden moves:
 *    - Store commitment: hash256(nonce + move)
 *    - Verify on reveal: hash256(revealedNonce + revealedMove) === commitment
 * 
 * 4. Timeout handling:
 *    assert(this.ctx.locktime >= this.timeoutHeight, "timeout not reached");
 *    assert(this.ctx.sequence < 0xffffffff, "nLocktime must be enabled");
 */
export class Contract extends SmartContract {{
  @prop()
  player1: PubKey;

  @prop()
  player2: PubKey;

  @prop()
  timeoutBlockHeight: bigint;

  constructor(
    player1: PubKey,
    player2: PubKey,
    timeoutBlockHeight: bigint,
  ) {{
    super(...arguments);
    this.player1 = player1;
    this.player2 = player2;
    this.timeoutBlockHeight = timeoutBlockHeight;
  }}

  /**
   * Main interaction method
   * 
   * Uses ANYONECANPAY_SINGLE:
   * - Input 0: Contract UTXO
   * - Input 1+: Fee UTXOs (added by custom tx builder)
   * - Output 0: Payout (verified by contract)
   * - Output 1+: Change (not verified)
   */
  @method(SigHash.ANYONECANPAY_SINGLE)
  public settle(
    callerIsPlayer1: boolean,
    callerSig: Sig
  ) {{
    const callerPubKey: PubKey = callerIsPlayer1 ? this.player1 : this.player2;
    assert(this.checkSig(callerSig, callerPubKey), "sig required");
    
    // TODO: Implement your game/business logic here
    // Determine winner and build payout output
    
    // Example: Winner takes all
    const winnerPkh: PubKeyHash = hash160(callerPubKey);
    const outputs = Utils.buildPublicKeyHashOutput(winnerPkh, this.ctx.utxo.value);
    
    // Verify output 0 matches (SINGLE sighash)
    assert(this.ctx.hashOutputs === hash256(outputs), "outputs mismatch");
  }}

  /**
   * Timeout claim - if opponent doesn't respond
   */
  @method(SigHash.ANYONECANPAY_SINGLE)
  public claimAfterTimeout(sig: Sig) {{
    // Verify timeout reached
    assert(this.ctx.locktime >= this.timeoutBlockHeight, "timeout not reached");
    assert(this.ctx.sequence < 0xffffffffn, "nLocktime must be enabled");
    
    // Either player can claim after timeout
    assert(
      this.checkSig(sig, this.player1) || this.checkSig(sig, this.player2),
      "player sig required"
    );
    
    // Claimant gets full value
    const claimantPkh: PubKeyHash = hash160(this.player1);
    const outputs = Utils.buildPublicKeyHashOutput(claimantPkh, this.ctx.utxo.value);
    assert(this.ctx.hashOutputs === hash256(outputs), "outputs mismatch");
  }}
}}

export default Contract;
"#
    )
}

// ============================================================================
// WALLET UTILITIES (shared across frameworks)
// ============================================================================

pub const WALLET_UTILS: &str = r#"/**
 * Yours Wallet connection utilities for BSV blockchain
 * 
 * Yours Wallet (formerly Panda Wallet) is a browser extension that provides
 * direct signing capabilities without requiring an OAuth backend.
 */

export type WalletType = "yours" | null;

export interface WalletState {
  connected: boolean;
  address: string | null;
  balance: number;
  loading: boolean;
  error: string | null;
  walletType: WalletType;
}

const STORAGE_KEY = "bsv_wallet";

/**
 * Connect to Yours Wallet browser extension
 */
export async function connectYoursWallet(): Promise<{ address: string; walletType: WalletType }> {
  // Dynamic import to avoid issues with SSR
  const { getPandaSigner } = await import("../services/pandaSignerService");
  const signer = await getPandaSigner(true);
  const addr = await signer.getDefaultAddress();
  const address = addr.toString();
  const walletType: WalletType = "yours";
  localStorage.setItem(STORAGE_KEY, JSON.stringify({ address, walletType }));
  return { address, walletType };
}

/**
 * Legacy connect function for backwards compatibility
 */
export async function connectWallet(): Promise<{ address: string }> {
  return connectYoursWallet();
}

export function createInitialWalletState(): WalletState {
  return {
    connected: false,
    address: null,
    balance: 0,
    loading: false,
    error: null,
    walletType: null,
  };
}

export function getStoredAuth(): { address: string; walletType: WalletType } | null {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return null;
  try {
    const parsed = JSON.parse(raw);
    if (parsed.walletType !== "yours") {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}

export function getActiveWalletType(): WalletType {
  const stored = getStoredAuth();
  return stored?.walletType || null;
}

export function disconnectWallet(): void {
  localStorage.removeItem(STORAGE_KEY);
}
"#;

pub const PANDA_SIGNER_SERVICE: &str = r#"/**
 * PandaSigner Service - SDK-level signer for Yours Wallet
 * 
 * This provides the basic PandaSigner from scrypt-ts SDK.
 * For advanced use cases (custom tx building, bypassing proxy bugs),
 * use YoursDirectSigner from yoursWalletDirect.ts instead.
 */

import {
  PandaSigner,
  DefaultProvider,
  bsv,
  type Provider,
} from "scrypt-ts";

const NETWORK = import.meta.env.VITE_BSV_NETWORK || "mainnet";

let cachedSigner: PandaSigner | null = null;
let cachedProvider: Provider | null = null;

function assertWalletInjected() {
  if (typeof window === "undefined") return;
  const w = window as any;
  const hasInjection = !!(w.panda || w.yours);
  if (!hasInjection) {
    throw new Error(
      "Yours Wallet not detected. Please install the Yours Wallet extension from the Chrome Web Store and refresh the page.",
    );
  }
}

function getNetworkFromString(networkStr: string): bsv.Networks.Network {
  const lowerNetwork = networkStr.toLowerCase();
  if (lowerNetwork === "testnet" || lowerNetwork.includes("testnet")) {
    return bsv.Networks.testnet;
  }
  return bsv.Networks.mainnet;
}

async function getProvider(): Promise<Provider> {
  if (cachedProvider) return cachedProvider;
  const network = getNetworkFromString(NETWORK as string);
  const provider = new DefaultProvider({ network });
  await provider.connect();
  cachedProvider = provider;
  return provider;
}

export async function getPandaSigner(auth: boolean = false): Promise<PandaSigner> {
  assertWalletInjected();
  if (cachedSigner) {
    return cachedSigner;
  }
  const provider = await getProvider();
  const signer = new PandaSigner(provider);
  if (auth) {
    const authResult = await signer.requestAuth();
    if (!authResult.isAuthenticated) {
      throw new Error("Yours Wallet authentication failed: " + authResult.error);
    }
  }
  cachedSigner = signer;
  return signer;
}

export function clearPandaSigner() {
  cachedSigner = null;
  cachedProvider = null;
}

export async function getFreshPandaSigner(auth: boolean = false): Promise<PandaSigner> {
  clearPandaSigner();
  return getPandaSigner(auth);
}
"#;

pub const YOURS_DIRECT_SIGNER: &str = r#"/**
 * YoursDirectSigner - Custom Signer implementation for Yours Wallet
 * 
 * This bypasses PandaSigner proxy bugs by implementing a clean Signer
 * that routes signing through window.yours.getSignatures().
 * 
 * USE THIS for settlement transactions that require custom tx building.
 * The standard PandaSigner can have issues with:
 * - Proxy object interference
 * - Incorrect sighash handling
 * - Fee calculation problems
 */

import {
  bsv,
  Signer,
  SignatureRequest,
  SignatureResponse,
  Provider,
  AddressOption,
  DefaultProvider,
} from "scrypt-ts";

// Yours Wallet API types (from window.yours)
interface YoursWalletAPI {
  isConnected: () => Promise<boolean>;
  connect: () => Promise<string>;
  getAddresses: () => Promise<{ bsvAddress: string; ordAddress: string; identityAddress: string }>;
  getPubKeys: () => Promise<{ bsvPubKey: string; ordPubKey: string; identityPubKey: string }>;
  getBalance: () => Promise<{ bsv: number; satoshis: number; usdInCents: number }>;
  getPaymentUtxos: () => Promise<Array<{ satoshis: number; script: string; txid: string; vout: number }>>;
  getSignatures: (params: {
    rawtx: string;
    sigRequests: Array<{
      prevTxid: string;
      outputIndex: number;
      inputIndex: number;
      satoshis: number;
      address: string | string[];
      script?: string;
      sigHashType?: number;
      csIdx?: number;
      data?: unknown;
    }>;
  }) => Promise<Array<{
    inputIndex: number;
    sig: string;
    pubKey: string;
    sigHashType: number;
    csIdx?: number;
  }>>;
  broadcast: (params: { rawtx: string; format?: string }) => Promise<string>;
  signMessage: (params: { message: string }) => Promise<{ sig: string }>;
}

const NETWORK = import.meta.env.VITE_BSV_NETWORK || "mainnet";

function getNetworkFromString(networkStr: string): bsv.Networks.Network {
  const lowerNetwork = networkStr.toLowerCase();
  if (lowerNetwork === "testnet" || lowerNetwork.includes("testnet")) {
    return bsv.Networks.testnet;
  }
  return bsv.Networks.mainnet;
}

/**
 * Custom Signer that uses Yours Wallet's direct API for signing.
 */
export class YoursDirectSigner extends Signer {
  private _target: YoursWalletAPI | null = null;
  private _network: bsv.Networks.Network;
  
  constructor(provider?: Provider) {
    super(provider);
    this._network = getNetworkFromString(NETWORK);
  }
  
  private _initTarget(): void {
    if (this._target) return;
    if (typeof (window as any).yours !== 'undefined') {
      this._target = (window as any).yours;
    } else {
      throw new Error('Yours Wallet is not installed. Please install the extension and refresh.');
    }
  }
  
  private async getConnectedTarget(): Promise<YoursWalletAPI> {
    const isAuthenticated = await this.isAuthenticated();
    if (!isAuthenticated) {
      this._initTarget();
      const res = await this._target!.connect();
      if (res && res.includes("canceled")) {
        throw new Error(res);
      }
    }
    return this._target!;
  }
  
  override async getNetwork(): Promise<bsv.Networks.Network> {
    return this._network;
  }
  
  override async isAuthenticated(): Promise<boolean> {
    try {
      this._initTarget();
      return await this._target!.isConnected();
    } catch {
      return false;
    }
  }
  
  override async requestAuth(): Promise<{ isAuthenticated: boolean; error: string }> {
    let isAuthenticated = false;
    let error = '';
    try {
      await this.getConnectedTarget();
      isAuthenticated = true;
    } catch (e: any) {
      error = e.message || String(e);
    }
    return { isAuthenticated, error };
  }
  
  override setProvider(provider: Provider): void {
    this.provider = provider;
  }
  
  override async getDefaultAddress(): Promise<bsv.Address> {
    const yours = await this.getConnectedTarget();
    const addresses = await yours.getAddresses();
    return bsv.Address.fromString(addresses.bsvAddress);
  }
  
  override async getDefaultPubKey(): Promise<bsv.PublicKey> {
    const yours = await this.getConnectedTarget();
    const pubKeys = await yours.getPubKeys();
    return new bsv.PublicKey(pubKeys.bsvPubKey);
  }
  
  override async getPubKey(_address?: AddressOption): Promise<bsv.PublicKey> {
    return this.getDefaultPubKey();
  }
  
  override async signMessage(message: string, address?: AddressOption): Promise<string> {
    if (address) {
      throw new Error("signMessage with 'address' param is not supported");
    }
    const yours = await this.getConnectedTarget();
    const res = await yours.signMessage({ message });
    return res.sig;
  }
  
  /**
   * THE CRITICAL METHOD: Get signatures for transaction inputs
   * 
   * Converts scrypt-ts format to Yours Wallet format and back.
   */
  override async getSignatures(
    rawTxHex: string,
    sigRequests: SignatureRequest[]
  ): Promise<SignatureResponse[]> {
    const yours = await this.getConnectedTarget();
    
    // Convert scrypt-ts SignatureRequest to Yours Wallet format
    const yoursRequests = sigRequests.map((sigReq) => {
      let addressStrings: string[];
      if (typeof sigReq.address === 'string') {
        addressStrings = [sigReq.address];
      } else if (Array.isArray(sigReq.address)) {
        addressStrings = sigReq.address.map((addr) => 
          typeof addr === 'string' ? addr : addr.toString()
        );
      } else {
        addressStrings = [(sigReq.address as bsv.Address).toString()];
      }
      
      return {
        prevTxid: sigReq.prevTxId,
        outputIndex: sigReq.outputIndex,
        inputIndex: sigReq.inputIndex,
        satoshis: sigReq.satoshis,
        address: addressStrings.length === 1 ? addressStrings[0] : addressStrings,
        script: sigReq.scriptHex,
        sigHashType: sigReq.sigHashType,
        csIdx: sigReq.csIdx,
        data: sigReq.data,
      };
    });
    
    const sigResults = await yours.getSignatures({
      rawtx: rawTxHex,
      sigRequests: yoursRequests,
    });
    
    // Convert back to scrypt-ts format (pubKey -> publicKey)
    return sigResults.map((sigResult) => ({
      inputIndex: sigResult.inputIndex,
      sig: sigResult.sig,
      publicKey: sigResult.pubKey,
      sigHashType: sigResult.sigHashType,
      csIdx: sigResult.csIdx,
    }));
  }
  
  override async getBalance(address?: AddressOption): Promise<{ confirmed: number; unconfirmed: number }> {
    if (address) {
      return this.connectedProvider.getBalance(address);
    }
    const yours = await this.getConnectedTarget();
    const balance = await yours.getBalance();
    return { confirmed: balance.satoshis, unconfirmed: 0 };
  }
}

// Signer instance management
let yoursSignerInstance: YoursDirectSigner | null = null;

export async function getYoursDirectSigner(): Promise<YoursDirectSigner> {
  if (yoursSignerInstance) {
    return yoursSignerInstance;
  }
  
  const network = getNetworkFromString(NETWORK);
  const provider = new DefaultProvider({ network });
  await provider.connect();
  
  const signer = new YoursDirectSigner(provider);
  const authResult = await signer.requestAuth();
  
  if (!authResult.isAuthenticated) {
    throw new Error("Yours Wallet auth failed: " + authResult.error);
  }
  
  yoursSignerInstance = signer;
  return signer;
}

export function clearYoursDirectSigner(): void {
  yoursSignerInstance = null;
}

/**
 * Get wallet UTXOs for fee payment
 */
export async function getWalletUtxos(): Promise<Array<{ satoshis: number; script: string; txid: string; vout: number }>> {
  const yours = (window as any).yours;
  if (!yours) {
    throw new Error("Yours Wallet not available");
  }
  return yours.getPaymentUtxos();
}
"#;

pub const CONTRACT_SERVICE: &str = r#"/**
 * Contract Service - Production-ready sCrypt smart contract interactions
 * 
 * KEY PATTERNS IMPLEMENTED:
 * 1. Dynamic artifact loading (no direct .scrypt.ts imports)
 * 2. YoursDirectSigner for reliable signing
 * 3. Custom tx builder with bindTxBuilder for full control
 * 4. Manual fee UTXO handling with feePerKb
 * 5. Proper change address handling
 * 
 * IMPORTANT: Do NOT import .scrypt.ts files directly!
 * Compile first: npx scrypt-cli compile
 */

import {
  hash256,
  toByteString,
  bsv,
  PubKey,
  ByteString,
  MethodCallOptions,
  findSig,
  Utils,
  hash160,
  ContractTransaction,
  type Signer,
} from "scrypt-ts";
import Contract from "../../contracts/Contract.scrypt";
import { getPandaSigner, getFreshPandaSigner } from "./pandaSignerService";
import { getYoursDirectSigner, getWalletUtxos } from "./yoursWalletDirect";
import { getActiveWalletType } from "../lib/wallet";

// ============================================================================
// ARTIFACT LOADING
// ============================================================================

let artifactLoaded = false;

async function loadArtifact() {
  if (artifactLoaded) return;
  const artifactPath =
    import.meta.env.VITE_ARTIFACT_PATH ||
    "/artifacts/contracts/Contract.scrypt.json";
  try {
    const res = await fetch(artifactPath);
    if (!res.ok) {
      throw new Error("HTTP " + res.status);
    }
    const artifact = await res.json();
    await Contract.loadArtifact(artifact);
    artifactLoaded = true;
  } catch (err) {
    throw new Error(
      "Contract artifact missing at " + artifactPath + ". Run " +
      "`npx scrypt-cli compile` to generate it.",
    );
  }
}

// ============================================================================
// SIGNER HELPERS
// ============================================================================

async function getSigner(auth: boolean = true): Promise<Signer> {
  const walletType = getActiveWalletType();
  if (walletType === "yours") {
    return getYoursDirectSigner();
  }
  return getPandaSigner(auth);
}

export async function getSignerPubKeyHex(): Promise<string> {
  const signer = await getSigner(true);
  const pub = await signer.getDefaultPubKey();
  return pub.toHex();
}

// ============================================================================
// COMMITMENT HASHING (for commit-reveal patterns)
// ============================================================================

export function hashCommitment(data: string, nonce: string): string {
  return hash256(toByteString(nonce + data, true));
}

// ============================================================================
// DEPLOYMENT
// ============================================================================

export interface DeployParams {
  player1PubKeyHex: string;
  player2PubKeyHex: string;
  player1Commitment: string;
  player2Commitment: string;
  timeoutHeight: bigint;
  fundingSats: number;
}

export async function deployContract(params: DeployParams) {
  await loadArtifact();
  
  const signer = await getYoursDirectSigner();
  
  const contract = new Contract(
    PubKey(params.player1PubKeyHex),
    PubKey(params.player2PubKeyHex),
    params.player1Commitment as ByteString,
    params.player2Commitment as ByteString,
    params.timeoutHeight,
  );
  
  await contract.connect(signer);
  
  const pot = BigInt(params.fundingSats * 2);
  const tx = await contract.deploy(Number(pot));
  
  return { txid: tx.id, instance: contract };
}

// ============================================================================
// CUSTOM TRANSACTION BUILDER
// 
// This is the KEY pattern for controlling transaction construction.
// Use bindTxBuilder to register this before calling contract methods.
// ============================================================================

async function buildSettleTx(
  current: Contract,
  options: MethodCallOptions<Contract>,
  ...methodArgs: any[]
): Promise<ContractTransaction> {
  // Extract method arguments (customize based on your contract)
  const [p1Move, _p1Nonce, p2Move, _p2Nonce, callerIsPlayer1, _sig] = methodArgs;
  
  // Get contract properties
  const player1Hex = (current as any).player1 as string;
  const player2Hex = (current as any).player2 as string;
  
  // Decode moves to determine outcome
  const p1MoveStr = Buffer.from(p1Move, 'hex').toString('utf8');
  const p2MoveStr = Buffer.from(p2Move, 'hex').toString('utf8');
  
  // Determine winner (customize this logic for your game)
  let winnerPubKeyHex: string;
  let isDraw = p1MoveStr === p2MoveStr;
  
  if (isDraw) {
    winnerPubKeyHex = player1Hex;
  } else {
    // Example: rock-paper-scissors logic
    const p1Wins = 
      (p1MoveStr === "rock" && p2MoveStr === "scissors") ||
      (p1MoveStr === "scissors" && p2MoveStr === "paper") ||
      (p1MoveStr === "paper" && p2MoveStr === "rock");
    winnerPubKeyHex = p1Wins ? player1Hex : player2Hex;
  }
  
  // Create transaction with contract input at index 0
  const unsignedTx: bsv.Transaction = new bsv.Transaction();
  unsignedTx.addInput(current.buildContractInput());
  
  // Build output 0 using Utils.buildPublicKeyHashScript (matches contract)
  const winnerPkh = hash160(winnerPubKeyHex as PubKey);
  const script = Utils.buildPublicKeyHashScript(winnerPkh);
  
  if (isDraw) {
    const halfAmount = Math.floor(current.balance / 2);
    unsignedTx.addOutput(new bsv.Transaction.Output({
      script: bsv.Script.fromHex(script),
      satoshis: halfAmount,
    }));
    // Output 1 for player 2
    const p2Pkh = hash160(player2Hex as PubKey);
    const p2Script = Utils.buildPublicKeyHashScript(p2Pkh);
    unsignedTx.addOutput(new bsv.Transaction.Output({
      script: bsv.Script.fromHex(p2Script),
      satoshis: halfAmount,
    }));
  } else {
    unsignedTx.addOutput(new bsv.Transaction.Output({
      script: bsv.Script.fromHex(script),
      satoshis: current.balance,
    }));
  }
  
  // CRITICAL: Manual fee funding
  // Pick one wallet UTXO to cover transaction fee
  const feeUtxos = await getWalletUtxos();
  if (!feeUtxos || feeUtxos.length === 0) {
    throw new Error("No UTXOs available for fee payment");
  }
  
  const MIN_FEE_SATS = 1000;
  const feeUtxo = feeUtxos.find((u) => u.satoshis >= MIN_FEE_SATS) || feeUtxos[0];
  
  // Add fee input (contract stays at index 0)
  unsignedTx.from({
    txId: feeUtxo.txid,
    outputIndex: feeUtxo.vout,
    script: feeUtxo.script,
    satoshis: feeUtxo.satoshis,
  });
  
  // Set fee rate and add change output
  unsignedTx.feePerKb(100); // 100 sat/KB - safe relay rate
  if (options.changeAddress) {
    unsignedTx.change(options.changeAddress);
  }
  
  return {
    tx: unsignedTx,
    atInputIndex: 0,
    nexts: [],
  };
}

// ============================================================================
// SETTLEMENT
// ============================================================================

export interface SettleParams {
  p1Move: string;
  p1Nonce: string;
  p2Move: string;
  p2Nonce: string;
  callerIsPlayer1: boolean;
  player1PubKeyHex: string;
  player2PubKeyHex: string;
}

export async function settleContract(
  instance: Contract,
  params: SettleParams,
): Promise<{ txid: string }> {
  await loadArtifact();
  
  const signer = await getYoursDirectSigner();
  await instance.connect(signer);
  
  // CRITICAL: Bind custom transaction builder
  instance.bindTxBuilder('settle', buildSettleTx);
  
  const callerPubKey = bsv.PublicKey.fromHex(
    params.callerIsPlayer1 ? params.player1PubKeyHex : params.player2PubKeyHex
  );
  
  const changeAddress = await signer.getDefaultAddress();
  
  const { tx: builtTx } = await instance.methods.settle(
    toByteString(params.p1Move, true),
    toByteString(params.p1Nonce, true),
    toByteString(params.p2Move, true),
    toByteString(params.p2Nonce, true),
    params.callerIsPlayer1,
    (sigResps: any) => findSig(sigResps, callerPubKey),
    {
      pubKeyOrAddrToSign: callerPubKey,
      changeAddress: changeAddress,
    } as MethodCallOptions<Contract>,
  );
  
  return { txid: builtTx.id };
}

// ============================================================================
// CONTRACT RESTORATION (from deployed tx)
// ============================================================================

export async function restoreContractFromTx(txid: string, outputIndex: number = 0): Promise<Contract> {
  await loadArtifact();
  
  const signer = await getYoursDirectSigner();
  const provider = signer.provider!;
  const tx = await provider.getTransaction(txid);
  
  const instance = Contract.fromTx(tx, outputIndex);
  await instance.connect(signer);
  
  return instance;
}

export default {
  deployContract,
  settleContract,
  restoreContractFromTx,
  getSignerPubKeyHex,
  hashCommitment,
};
"#;

// ============================================================================
// REACT TEMPLATES
// ============================================================================

pub fn react_files(contract_name: &str) -> Vec<(&'static str, String)> {
    vec![
        ("src/main.tsx", REACT_MAIN.to_string()),
        ("src/App.tsx", format!(r#"import {{ useState, useEffect }} from "react";
import {{ WalletProvider }} from "./components/WalletProvider";
import {{ Game }} from "./components/Game";
import "./index.css";

export default function App() {{
  return (
    <WalletProvider>
      <div className="min-h-screen bg-slate-900 text-slate-100">
        <header className="border-b border-slate-700 p-4">
          <div className="max-w-4xl mx-auto flex justify-between items-center">
            <h1 className="text-2xl font-bold">Bitcoin App</h1>
            <div id="wallet-button"></div>
          </div>
        </header>
        <main className="max-w-4xl mx-auto p-4">
          <Game contractName="{contract_name}" />
        </main>
      </div>
    </WalletProvider>
  );
}}
"#)),
        ("src/components/WalletProvider.tsx", REACT_WALLET_PROVIDER.to_string()),
        ("src/components/WalletButton.tsx", REACT_WALLET_BUTTON.to_string()),
        ("src/components/Game.tsx", REACT_GAME_COMPONENT.to_string()),
        ("src/lib/wallet.ts", WALLET_UTILS.to_string()),
        ("src/services/pandaSignerService.ts", PANDA_SIGNER_SERVICE.to_string()),
        ("src/services/yoursWalletDirect.ts", YOURS_DIRECT_SIGNER.to_string()),
        ("src/services/contractService.ts", CONTRACT_SERVICE.to_string()),
        ("src/index.css", TAILWIND_CSS.to_string()),
        ("src/vite-env.d.ts", VITE_ENV_DTS.to_string()),
        ("index.html", REACT_INDEX_HTML.to_string()),
        ("vite.config.ts", REACT_VITE_CONFIG.to_string()),
        ("tsconfig.json", REACT_TSCONFIG.to_string()),
        ("tsconfig.node.json", TSCONFIG_NODE.to_string()),
        ("tailwind.config.js", TAILWIND_CONFIG.to_string()),
        ("postcss.config.js", POSTCSS_CONFIG.to_string()),
        ("package.json", react_package_json()),
    ]
}

const REACT_MAIN: &str = r#"import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
"#;

const REACT_WALLET_PROVIDER: &str = r#"import { createContext, useContext, useState, useEffect, ReactNode } from "react";
import { WalletState, createInitialWalletState, getStoredAuth, disconnectWallet, connectYoursWallet } from "../lib/wallet";

interface WalletContextType {
  wallet: WalletState;
  connect: () => void;
  disconnect: () => void;
}

const WalletContext = createContext<WalletContextType | null>(null);

export function WalletProvider({ children }: { children: ReactNode }) {
  const [wallet, setWallet] = useState<WalletState>(createInitialWalletState());

  useEffect(() => {
    // Check for stored auth
    const stored = getStoredAuth();
    if (stored) {
      setWallet({
        connected: true,
        address: stored.address,
        balance: 0,
        loading: false,
        error: null,
        walletType: stored.walletType,
      });
      return;
    }
  }, []);

  const connect = async () => {
    setWallet(prev => ({ ...prev, loading: true, error: null }));
    try {
      const res = await connectYoursWallet();
      setWallet({
        connected: true,
        address: res.address,
        balance: 0,
        loading: false,
        error: null,
        walletType: res.walletType,
      });
    } catch (err: any) {
      setWallet(prev => ({ 
        ...prev, 
        loading: false, 
        error: err?.message || "Failed to connect Yours Wallet" 
      }));
    }
  };

  const disconnect = () => {
    disconnectWallet();
    setWallet(createInitialWalletState());
  };

  return (
    <WalletContext.Provider value={{ wallet, connect, disconnect }}>
      {children}
    </WalletContext.Provider>
  );
}

export function useWallet() {
  const context = useContext(WalletContext);
  if (!context) throw new Error("useWallet must be used within WalletProvider");
  return context;
}
"#;

const REACT_WALLET_BUTTON: &str = r#"import { useWallet } from "./WalletProvider";

export function WalletButton() {
  const { wallet, connect, disconnect } = useWallet();

  if (wallet.loading) {
    return <button className="btn" disabled>Connecting...</button>;
  }

  if (wallet.connected) {
    return (
      <div className="flex items-center gap-2">
        <span className="text-sm text-slate-400">{wallet.address}</span>
        <button onClick={disconnect} className="btn btn-secondary">
          Disconnect
        </button>
      </div>
    );
  }

  return (
    <button onClick={connect} className="btn btn-primary">
      Connect Yours Wallet
    </button>
  );
}
"#;

const REACT_GAME_COMPONENT: &str = r#"import { useWallet } from "./WalletProvider";
import { WalletButton } from "./WalletButton";

interface GameProps {
  contractName: string;
}

export function Game({ contractName }: GameProps) {
  const { wallet } = useWallet();

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <h2 className="text-xl font-semibold">Game</h2>
        <WalletButton />
      </div>

      {!wallet.connected ? (
        <div className="text-center py-12 bg-slate-800 rounded-lg">
          <p className="text-slate-400 mb-4">Connect your wallet to play</p>
        </div>
      ) : (
        <div className="bg-slate-800 rounded-lg p-6">
          <p className="text-slate-400 mb-4">Contract: {contractName}</p>
          {/* TODO: Implement game UI here */}
          <p className="text-center text-slate-500">
            Game interface will be implemented here
          </p>
        </div>
      )}
    </div>
  );
}
"#;

const REACT_INDEX_HTML: &str = r#"<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bitcoin App</title>
  </head>
  <body class="bg-slate-900">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
"#;

const REACT_VITE_CONFIG: &str = r#"import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
  },
});
"#;

const REACT_TSCONFIG: &str = r#"{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
"#;

fn react_package_json() -> String {
    r#"{
  "name": "bitcoin-app",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "scrypt-ts": "^1.3.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vitejs/plugin-react": "^4.2.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0"
  }
}
"#.to_string()
}

// ============================================================================
// VUE TEMPLATES
// ============================================================================

pub fn vue_files(contract_name: &str) -> Vec<(&'static str, String)> {
    vec![
        ("src/main.ts", VUE_MAIN.to_string()),
        ("src/App.vue", format!(r#"<script setup lang="ts">
import {{ provide }} from "vue";
import {{ useWallet }} from "./composables/useWallet";
import WalletButton from "./components/WalletButton.vue";
import Game from "./components/Game.vue";

const wallet = useWallet();
provide("wallet", wallet);
</script>

<template>
  <div class="min-h-screen bg-slate-900 text-slate-100">
    <header class="border-b border-slate-700 p-4">
      <div class="max-w-4xl mx-auto flex justify-between items-center">
        <h1 class="text-2xl font-bold">Bitcoin App</h1>
        <WalletButton />
      </div>
    </header>
    <main class="max-w-4xl mx-auto p-4">
      <Game contract-name="{contract_name}" />
    </main>
  </div>
</template>
"#)),
        ("src/components/WalletButton.vue", VUE_WALLET_BUTTON.to_string()),
        ("src/components/Game.vue", VUE_GAME_COMPONENT.to_string()),
        ("src/composables/useWallet.ts", VUE_USE_WALLET.to_string()),
        ("src/lib/wallet.ts", WALLET_UTILS.to_string()),
        ("src/services/pandaSignerService.ts", PANDA_SIGNER_SERVICE.to_string()),
        ("src/services/yoursWalletDirect.ts", YOURS_DIRECT_SIGNER.to_string()),
        ("src/services/contractService.ts", CONTRACT_SERVICE.to_string()),
        ("src/style.css", TAILWIND_CSS.to_string()),
        ("src/vite-env.d.ts", VITE_ENV_DTS.to_string()),
        ("index.html", VUE_INDEX_HTML.to_string()),
        ("vite.config.ts", VUE_VITE_CONFIG.to_string()),
        ("tsconfig.json", VUE_TSCONFIG.to_string()),
        ("tsconfig.node.json", TSCONFIG_NODE.to_string()),
        ("tailwind.config.js", TAILWIND_CONFIG.to_string()),
        ("postcss.config.js", POSTCSS_CONFIG.to_string()),
        ("package.json", vue_package_json()),
    ]
}

const VUE_MAIN: &str = r##"import { createApp } from "vue";
import App from "./App.vue";
import "./style.css";

createApp(App).mount("#app");
"##;

const VUE_USE_WALLET: &str = r#"import { ref, onMounted } from "vue";
import {
  WalletState,
  createInitialWalletState,
  getStoredAuth,
  disconnectWallet,
  connectYoursWallet,
} from "../lib/wallet";

export function useWallet() {
  const wallet = ref<WalletState>(createInitialWalletState());

  onMounted(async () => {
    // Check for stored auth
    const stored = getStoredAuth();
    if (stored) {
      wallet.value = {
        connected: true,
        address: stored.address,
        balance: 0,
        loading: false,
        error: null,
        walletType: stored.walletType,
      };
      return;
    }
  });

  const connect = async () => {
    wallet.value.loading = true;
    wallet.value.error = null;
    try {
      const res = await connectYoursWallet();
      wallet.value = {
        connected: true,
        address: res.address,
        balance: 0,
        loading: false,
        error: null,
        walletType: res.walletType,
      };
    } catch (err: any) {
      wallet.value.loading = false;
      wallet.value.error = err?.message || "Failed to connect Yours Wallet";
    }
  };

  const disconnect = () => {
    disconnectWallet();
    wallet.value = createInitialWalletState();
  };

  return { wallet, connect, disconnect };
}
"#;

const VUE_WALLET_BUTTON: &str = r#"<script setup lang="ts">
import { inject } from "vue";

const { wallet, connect, disconnect } = inject("wallet") as any;
</script>

<template>
  <button v-if="wallet.loading" class="btn" disabled>Connecting...</button>
  <div v-else-if="wallet.connected" class="flex items-center gap-2">
    <span class="text-sm text-slate-400">{{ wallet.address }}</span>
    <button @click="disconnect" class="btn btn-secondary">Disconnect</button>
  </div>
  <button v-else @click="connect" class="btn btn-primary">Connect Yours Wallet</button>
</template>
"#;

const VUE_GAME_COMPONENT: &str = r#"<script setup lang="ts">
import { inject } from "vue";
import WalletButton from "./WalletButton.vue";

defineProps<{ contractName: string }>();

const { wallet } = inject("wallet") as any;
</script>

<template>
  <div class="space-y-8">
    <div class="flex justify-between items-center">
      <h2 class="text-xl font-semibold">Game</h2>
      <WalletButton />
    </div>

    <div v-if="!wallet.connected" class="text-center py-12 bg-slate-800 rounded-lg">
      <p class="text-slate-400 mb-4">Connect your wallet to play</p>
    </div>
    <div v-else class="bg-slate-800 rounded-lg p-6">
      <p class="text-slate-400 mb-4">Contract: {{ contractName }}</p>
      <!-- TODO: Implement game UI here -->
      <p class="text-center text-slate-500">Game interface will be implemented here</p>
    </div>
  </div>
</template>
"#;

const VUE_INDEX_HTML: &str = r#"<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bitcoin App</title>
  </head>
  <body class="bg-slate-900">
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
"#;

const VUE_VITE_CONFIG: &str = r#"import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],
  server: {
    port: 5173,
  },
});
"#;

const VUE_TSCONFIG: &str = r#"{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
"#;

fn vue_package_json() -> String {
    r#"{
  "name": "bitcoin-app",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.4.0",
    "scrypt-ts": "^1.3.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0",
    "vue-tsc": "^1.8.0"
  }
}
"#.to_string()
}

// ============================================================================
// NEXT.JS TEMPLATES
// ============================================================================

pub fn nextjs_files(contract_name: &str) -> Vec<(&'static str, String)> {
    vec![
        ("src/app/layout.tsx", NEXTJS_LAYOUT.to_string()),
        ("src/app/page.tsx", format!(r#""use client";

import {{ WalletProvider }} from "@/components/WalletProvider";
import {{ Game }} from "@/components/Game";

export default function Home() {{
  return (
    <WalletProvider>
      <div className="min-h-screen bg-slate-900 text-slate-100">
        <header className="border-b border-slate-700 p-4">
          <div className="max-w-4xl mx-auto flex justify-between items-center">
            <h1 className="text-2xl font-bold">Bitcoin App</h1>
          </div>
        </header>
        <main className="max-w-4xl mx-auto p-4">
          <Game contractName="{contract_name}" />
        </main>
      </div>
    </WalletProvider>
  );
}}
"#)),
        ("src/app/globals.css", TAILWIND_CSS.to_string()),
        ("src/components/WalletProvider.tsx", NEXTJS_WALLET_PROVIDER.to_string()),
        ("src/components/WalletButton.tsx", REACT_WALLET_BUTTON.to_string()),
        ("src/components/Game.tsx", REACT_GAME_COMPONENT.to_string()),
        ("src/lib/wallet.ts", NEXTJS_WALLET_UTILS.to_string()),
        ("src/services/pandaSignerService.ts", PANDA_SIGNER_SERVICE.to_string()),
        ("src/services/yoursWalletDirect.ts", YOURS_DIRECT_SIGNER.to_string()),
        ("src/services/contractService.ts", CONTRACT_SERVICE.to_string()),
        ("next.config.js", NEXTJS_CONFIG.to_string()),
        ("tsconfig.json", NEXTJS_TSCONFIG.to_string()),
        ("tailwind.config.ts", NEXTJS_TAILWIND_CONFIG.to_string()),
        ("postcss.config.js", POSTCSS_CONFIG.to_string()),
        ("package.json", nextjs_package_json()),
    ]
}

const NEXTJS_LAYOUT: &str = r#"import type { Metadata } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "Bitcoin App",
  description: "Bitcoin smart contract application",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className="bg-slate-900">{children}</body>
    </html>
  );
}
"#;


const NEXTJS_WALLET_PROVIDER: &str = r#""use client";

import { createContext, useContext, useState, useEffect, ReactNode } from "react";

type WalletType = "yours" | null;

interface WalletState {
  connected: boolean;
  address: string | null;
  balance: number;
  loading: boolean;
  error: string | null;
  walletType: WalletType;
}

interface WalletContextType {
  wallet: WalletState;
  connect: () => void;
  disconnect: () => void;
}

const STORAGE_KEY = "bsv_wallet";
const WalletContext = createContext<WalletContextType | null>(null);

export function WalletProvider({ children }: { children: ReactNode }) {
  const [wallet, setWallet] = useState<WalletState>({
    connected: false,
    address: null,
    balance: 0,
    loading: false,
    error: null,
    walletType: null,
  });

  useEffect(() => {
    // Check for stored auth
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        if (parsed.walletType === "yours") {
          setWallet({
            connected: true,
            address: parsed.address,
            balance: 0,
            loading: false,
            error: null,
            walletType: parsed.walletType,
          });
        }
      } catch {}
    }
  }, []);

  const connect = async () => {
    setWallet(prev => ({ ...prev, loading: true, error: null }));
    try {
      const { getPandaSigner } = await import("@/services/pandaSignerService");
      const signer = await getPandaSigner(true);
      const addr = await signer.getDefaultAddress();
      const address = addr.toString();
      const walletType: WalletType = "yours";
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ address, walletType }));
      setWallet({
        connected: true,
        address,
        balance: 0,
        loading: false,
        error: null,
        walletType,
      });
    } catch (err: any) {
      setWallet(prev => ({ 
        ...prev, 
        loading: false, 
        error: err?.message || "Failed to connect Yours Wallet" 
      }));
    }
  };

  const disconnect = () => {
    localStorage.removeItem(STORAGE_KEY);
    setWallet({
      connected: false,
      address: null,
      balance: 0,
      loading: false,
      error: null,
      walletType: null,
    });
  };

  return (
    <WalletContext.Provider value={{ wallet, connect, disconnect }}>
      {children}
    </WalletContext.Provider>
  );
}

export function useWallet() {
  const context = useContext(WalletContext);
  if (!context) throw new Error("useWallet must be used within WalletProvider");
  return context;
}
"#;

const NEXTJS_WALLET_UTILS: &str = r#"// Next.js uses server-side for sensitive operations
// Client-side wallet utilities

export interface WalletState {
  connected: boolean;
  address: string | null;
  balance: number;
  loading: boolean;
  error: string | null;
}

export interface DotWalletUser {
  user_open_id: string;
  user_name: string;
  user_avatar: string;
  pay_mail: string;
}
"#;

const NEXTJS_CONFIG: &str = r#"/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
};

module.exports = nextConfig;
"#;

const NEXTJS_TSCONFIG: &str = r#"{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": { "@/*": ["./src/*"] }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
"#;

const NEXTJS_TAILWIND_CONFIG: &str = r#"import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};

export default config;
"#;

fn nextjs_package_json() -> String {
    r#"{
  "name": "bitcoin-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "scrypt-ts": "^1.3.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.0"
  }
}
"#.to_string()
}

// ============================================================================
// ANGULAR TEMPLATES
// ============================================================================

pub fn angular_files(contract_name: &str) -> Vec<(&'static str, String)> {
    vec![
        ("src/main.ts", ANGULAR_MAIN.to_string()),
        ("src/index.html", ANGULAR_INDEX_HTML.to_string()),
        ("src/styles.css", TAILWIND_CSS.to_string()),
        ("src/app/app.component.ts", format!(r#"import {{ Component }} from "@angular/core";
import {{ CommonModule }} from "@angular/common";
import {{ WalletService }} from "./services/wallet.service";
import {{ WalletButtonComponent }} from "./components/wallet-button.component";
import {{ GameComponent }} from "./components/game.component";

@Component({{
  selector: "app-root",
  standalone: true,
  imports: [CommonModule, WalletButtonComponent, GameComponent],
  template: `
    <div class="min-h-screen bg-slate-900 text-slate-100">
      <header class="border-b border-slate-700 p-4">
        <div class="max-w-4xl mx-auto flex justify-between items-center">
          <h1 class="text-2xl font-bold">Bitcoin App</h1>
          <app-wallet-button></app-wallet-button>
        </div>
      </header>
      <main class="max-w-4xl mx-auto p-4">
        <app-game [contractName]="'{contract_name}'"></app-game>
      </main>
    </div>
  `,
}})
export class AppComponent {{}}
"#)),
        ("src/app/services/wallet.service.ts", ANGULAR_WALLET_SERVICE.to_string()),
        ("src/app/services/pandaSignerService.ts", PANDA_SIGNER_SERVICE.to_string()),
        ("src/app/services/yoursWalletDirect.ts", YOURS_DIRECT_SIGNER.to_string()),
        ("src/app/services/contract.service.ts", CONTRACT_SERVICE.to_string()),
        ("src/app/components/wallet-button.component.ts", ANGULAR_WALLET_BUTTON.to_string()),
        ("src/app/components/game.component.ts", ANGULAR_GAME_COMPONENT.to_string()),
        ("angular.json", ANGULAR_JSON.to_string()),
        ("tsconfig.json", ANGULAR_TSCONFIG.to_string()),
        ("tsconfig.app.json", ANGULAR_TSCONFIG_APP.to_string()),
        ("tailwind.config.js", TAILWIND_CONFIG.to_string()),
        ("postcss.config.js", POSTCSS_CONFIG.to_string()),
        ("package.json", angular_package_json()),
    ]
}

const ANGULAR_MAIN: &str = r#"import { bootstrapApplication } from "@angular/platform-browser";
import { AppComponent } from "./app/app.component";

bootstrapApplication(AppComponent).catch((err) => console.error(err));
"#;

const ANGULAR_INDEX_HTML: &str = r#"<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Bitcoin App</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body class="bg-slate-900">
    <app-root></app-root>
  </body>
</html>
"#;

const ANGULAR_WALLET_SERVICE: &str = r#"import { Injectable, signal } from "@angular/core";

export type WalletType = "yours" | null;

export interface WalletState {
  connected: boolean;
  address: string | null;
  balance: number;
  loading: boolean;
  error: string | null;
  walletType: WalletType;
}

const STORAGE_KEY = "bsv_wallet";

@Injectable({ providedIn: "root" })
export class WalletService {
  wallet = signal<WalletState>({
    connected: false,
    address: null,
    balance: 0,
    loading: false,
    error: null,
    walletType: null,
  });

  constructor() {
    // Check for stored auth on init
    const stored = this.getStoredAuth();
    if (stored) {
      this.wallet.set({
        connected: true,
        address: stored.address,
        balance: 0,
        loading: false,
        error: null,
        walletType: stored.walletType,
      });
    }
  }

  async connect() {
    this.wallet.update(w => ({ ...w, loading: true, error: null }));
    try {
      const { getPandaSigner } = await import("../services/pandaSignerService");
      const signer = await getPandaSigner(true);
      const addr = await signer.getDefaultAddress();
      const address = addr.toString();
      const walletType: WalletType = "yours";
      localStorage.setItem(STORAGE_KEY, JSON.stringify({ address, walletType }));
      this.wallet.set({
        connected: true,
        address,
        balance: 0,
        loading: false,
        error: null,
        walletType,
      });
    } catch (err: any) {
      this.wallet.update(w => ({ 
        ...w, 
        loading: false, 
        error: err?.message || "Failed to connect Yours Wallet" 
      }));
    }
  }

  disconnect() {
    localStorage.removeItem(STORAGE_KEY);
    this.wallet.set({
      connected: false,
      address: null,
      balance: 0,
      loading: false,
      error: null,
      walletType: null,
    });
  }

  private getStoredAuth(): { address: string; walletType: WalletType } | null {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    try {
      const parsed = JSON.parse(raw);
      if (parsed.walletType !== "yours") return null;
      return parsed;
    } catch {
      return null;
    }
  }
}
"#;

const ANGULAR_WALLET_BUTTON: &str = r#"import { Component, inject } from "@angular/core";
import { CommonModule } from "@angular/common";
import { WalletService } from "../services/wallet.service";

@Component({
  selector: "app-wallet-button",
  standalone: true,
  imports: [CommonModule],
  template: `
    <button *ngIf="walletService.wallet().loading" class="btn" disabled>
      Connecting...
    </button>
    <div *ngIf="walletService.wallet().connected" class="flex items-center gap-2">
      <span class="text-sm text-slate-400">{{ walletService.wallet().address }}</span>
      <button (click)="walletService.disconnect()" class="btn btn-secondary">
        Disconnect
      </button>
    </div>
    <button
      *ngIf="!walletService.wallet().connected && !walletService.wallet().loading"
      (click)="walletService.connect()"
      class="btn btn-primary"
    >
      Connect Yours Wallet
    </button>
  `,
})
export class WalletButtonComponent {
  walletService = inject(WalletService);
}
"#;

const ANGULAR_GAME_COMPONENT: &str = r#"import { Component, Input, inject } from "@angular/core";
import { CommonModule } from "@angular/common";
import { WalletService } from "../services/wallet.service";
import { WalletButtonComponent } from "./wallet-button.component";

@Component({
  selector: "app-game",
  standalone: true,
  imports: [CommonModule, WalletButtonComponent],
  template: `
    <div class="space-y-8">
      <div class="flex justify-between items-center">
        <h2 class="text-xl font-semibold">Game</h2>
        <app-wallet-button></app-wallet-button>
      </div>

      <div
        *ngIf="!walletService.wallet().connected"
        class="text-center py-12 bg-slate-800 rounded-lg"
      >
        <p class="text-slate-400 mb-4">Connect your wallet to play</p>
      </div>
      <div *ngIf="walletService.wallet().connected" class="bg-slate-800 rounded-lg p-6">
        <p class="text-slate-400 mb-4">Contract: {{ contractName }}</p>
        <!-- TODO: Implement game UI here -->
        <p class="text-center text-slate-500">Game interface will be implemented here</p>
      </div>
    </div>
  `,
})
export class GameComponent {
  @Input() contractName = "";
  walletService = inject(WalletService);
}
"#;

const ANGULAR_JSON: &str = r#"{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "bitcoin-app": {
      "projectType": "application",
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/bitcoin-app",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "tsConfig": "tsconfig.app.json",
            "styles": ["src/styles.css"],
            "scripts": []
          }
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "options": {
            "buildTarget": "bitcoin-app:build"
          }
        }
      }
    }
  }
}
"#;

const ANGULAR_TSCONFIG: &str = r#"{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022", "dom"]
  }
}
"#;

const ANGULAR_TSCONFIG_APP: &str = r#"{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "files": ["src/main.ts"],
  "include": ["src/**/*.d.ts"]
}
"#;

fn angular_package_json() -> String {
    r#"{
  "name": "bitcoin-app",
  "version": "0.1.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "dev": "ng serve",
    "build": "ng build"
  },
  "dependencies": {
    "@angular/common": "^17.0.0",
    "@angular/compiler": "^17.0.0",
    "@angular/core": "^17.0.0",
    "@angular/platform-browser": "^17.0.0",
    "@angular/platform-browser-dynamic": "^17.0.0",
    "rxjs": "~7.8.0",
    "tslib": "^2.3.0",
    "zone.js": "~0.14.0",
    "scrypt-ts": "^1.3.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^17.0.0",
    "@angular/cli": "^17.0.0",
    "@angular/compiler-cli": "^17.0.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "~5.2.0"
  }
}
"#.to_string()
}

// ============================================================================
// SVELTE TEMPLATES
// ============================================================================

pub fn svelte_files(contract_name: &str) -> Vec<(&'static str, String)> {
    vec![
        ("src/main.ts", SVELTE_MAIN.to_string()),
        ("src/App.svelte", format!(r#"<script lang="ts">
  import {{ wallet, connect, disconnect }} from "./stores/wallet";
  import WalletButton from "./components/WalletButton.svelte";
  import Game from "./components/Game.svelte";
</script>

<div class="min-h-screen bg-slate-900 text-slate-100">
  <header class="border-b border-slate-700 p-4">
    <div class="max-w-4xl mx-auto flex justify-between items-center">
      <h1 class="text-2xl font-bold">Bitcoin App</h1>
      <WalletButton />
    </div>
  </header>
  <main class="max-w-4xl mx-auto p-4">
    <Game contractName="{contract_name}" />
  </main>
</div>
"#)),
        ("src/components/WalletButton.svelte", SVELTE_WALLET_BUTTON.to_string()),
        ("src/components/Game.svelte", SVELTE_GAME_COMPONENT.to_string()),
        ("src/stores/wallet.ts", SVELTE_WALLET_STORE.to_string()),
        ("src/lib/wallet.ts", WALLET_UTILS.to_string()),
        ("src/services/pandaSignerService.ts", PANDA_SIGNER_SERVICE.to_string()),
        ("src/services/yoursWalletDirect.ts", YOURS_DIRECT_SIGNER.to_string()),
        ("src/services/contractService.ts", CONTRACT_SERVICE.to_string()),
        ("src/app.css", TAILWIND_CSS.to_string()),
        ("src/vite-env.d.ts", VITE_ENV_DTS.to_string()),
        ("index.html", SVELTE_INDEX_HTML.to_string()),
        ("vite.config.ts", SVELTE_VITE_CONFIG.to_string()),
        ("svelte.config.js", SVELTE_CONFIG.to_string()),
        ("tsconfig.json", SVELTE_TSCONFIG.to_string()),
        ("tsconfig.node.json", TSCONFIG_NODE.to_string()),
        ("tailwind.config.js", TAILWIND_CONFIG.to_string()),
        ("postcss.config.js", POSTCSS_CONFIG.to_string()),
        ("package.json", svelte_package_json()),
    ]
}

const SVELTE_MAIN: &str = r#"import "./app.css";
import App from "./App.svelte";

const app = new App({
  target: document.getElementById("app")!,
});

export default app;
"#;

const SVELTE_WALLET_STORE: &str = r#"import { writable } from "svelte/store";
import {
  WalletState,
  createInitialWalletState,
  getStoredAuth,
  disconnectWallet,
  connectYoursWallet,
} from "../lib/wallet";

function createWalletStore() {
  const { subscribe, set, update } = writable<WalletState>(createInitialWalletState());

  // Initialize on load
  if (typeof window !== "undefined") {
    const stored = getStoredAuth();
    if (stored) {
      set({
        connected: true,
        address: stored.address,
        balance: 0,
        loading: false,
        error: null,
        walletType: stored.walletType,
      });
    }
  }

  return {
    subscribe,
    connect: async () => {
      update(w => ({ ...w, loading: true, error: null }));
      try {
        const res = await connectYoursWallet();
        set({
          connected: true,
          address: res.address,
          balance: 0,
          loading: false,
          error: null,
          walletType: res.walletType,
        });
      } catch (err: any) {
        update(w => ({ ...w, loading: false, error: err?.message || "Failed to connect" }));
      }
    },
    disconnect: () => {
      disconnectWallet();
      set(createInitialWalletState());
    },
  };
}

export const wallet = createWalletStore();
export const { connect, disconnect } = wallet;
"#;

const SVELTE_WALLET_BUTTON: &str = r#"<script lang="ts">
  import { wallet, connect, disconnect } from "../stores/wallet";
</script>

{#if $wallet.loading}
  <button class="btn" disabled>Connecting...</button>
{:else if $wallet.connected}
  <div class="flex items-center gap-2">
    <span class="text-sm text-slate-400">{$wallet.address}</span>
    <button on:click={disconnect} class="btn btn-secondary">Disconnect</button>
  </div>
{:else}
  <button on:click={connect} class="btn btn-primary">Connect Yours Wallet</button>
{/if}
"#;

const SVELTE_GAME_COMPONENT: &str = r#"<script lang="ts">
  import { wallet } from "../stores/wallet";
  import WalletButton from "./WalletButton.svelte";

  export let contractName: string;
</script>

<div class="space-y-8">
  <div class="flex justify-between items-center">
    <h2 class="text-xl font-semibold">Game</h2>
    <WalletButton />
  </div>

  {#if !$wallet.connected}
    <div class="text-center py-12 bg-slate-800 rounded-lg">
      <p class="text-slate-400 mb-4">Connect your wallet to play</p>
    </div>
  {:else}
    <div class="bg-slate-800 rounded-lg p-6">
      <p class="text-slate-400 mb-4">Contract: {contractName}</p>
      <!-- TODO: Implement game UI here -->
      <p class="text-center text-slate-500">Game interface will be implemented here</p>
    </div>
  {/if}
</div>
"#;

const SVELTE_INDEX_HTML: &str = r#"<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bitcoin App</title>
  </head>
  <body class="bg-slate-900">
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
"#;

const SVELTE_VITE_CONFIG: &str = r#"import { defineConfig } from "vite";
import { svelte } from "@sveltejs/vite-plugin-svelte";

export default defineConfig({
  plugins: [svelte()],
  server: {
    port: 5173,
  },
});
"#;

const SVELTE_CONFIG: &str = r#"import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";

export default {
  preprocess: vitePreprocess(),
};
"#;

const SVELTE_TSCONFIG: &str = r#"{
  "extends": "@tsconfig/svelte/tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": true,
    "isolatedModules": true,
    "moduleDetection": "force"
  },
  "include": ["src/**/*.ts", "src/**/*.js", "src/**/*.svelte"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
"#;

fn svelte_package_json() -> String {
    r#"{
  "name": "bitcoin-app",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "scrypt-ts": "^1.3.0"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^3.0.0",
    "@tsconfig/svelte": "^5.0.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "svelte": "^4.2.0",
    "svelte-check": "^3.6.0",
    "tailwindcss": "^3.4.0",
    "tslib": "^2.6.0",
    "typescript": "^5.3.0",
    "vite": "^5.0.0"
  }
}
"#.to_string()
}

// ============================================================================
// SHARED TEMPLATES
// ============================================================================

const TAILWIND_CSS: &str = r#"@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .btn {
    @apply px-4 py-2 rounded-lg font-medium transition-colors;
  }
  .btn-primary {
    @apply bg-emerald-600 hover:bg-emerald-700 text-white;
  }
  .btn-secondary {
    @apply bg-slate-700 hover:bg-slate-600 text-slate-100;
  }
}
"#;

const TAILWIND_CONFIG: &str = r#"/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx,vue,svelte}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
"#;

const POSTCSS_CONFIG: &str = r#"export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
"#;

const TSCONFIG_NODE: &str = r#"{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
"#;

const VITE_ENV_DTS: &str = r#"/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_DOTWALLET_CLIENT_ID: string;
  readonly VITE_DOTWALLET_REDIRECT_URI: string;
  readonly VITE_OAUTH_BACKEND_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
"#;

// ============================================================================
// PUBLIC API
// ============================================================================

pub fn frontend_files(framework: Framework, contract_name: &str) -> Vec<(&'static str, String)> {
    match framework {
        Framework::React => react_files(contract_name),
        Framework::Vue => vue_files(contract_name),
        Framework::Nextjs => nextjs_files(contract_name),
        Framework::Angular => angular_files(contract_name),
        Framework::Svelte => svelte_files(contract_name),
    }
}

pub fn backend_files() -> Vec<(&'static str, String)> {
    // No backend needed - Yours Wallet is a browser extension
    vec![]
}

pub fn readme(framework: Framework, template: Template) -> String {
    format!(
        r#"# Bitcoin App ({:?} + {:?})

A Bitcoin smart contract application built with sCrypt and Yours Wallet.

## Prerequisites

1. **Yours Wallet** - Install the browser extension from the Chrome Web Store
2. **Node.js** 18+ and npm

## Quick Start

```bash
# Install dependencies
npm install

# Compile the smart contract
npx scrypt-cli compile

# Start the dev server
npm run dev
```

## Project Structure

```
 src/
    components/         # UI components
    lib/               # Utilities (wallet state)
    services/
       contractService.ts      # Contract deployment/settlement
       pandaSignerService.ts   # SDK signer wrapper
       yoursWalletDirect.ts    # Custom signer (for advanced use)
    ...
 contracts/             # sCrypt smart contracts (.scrypt.ts)
 artifacts/             # Compiled contract artifacts (generated)
 ...
```

## Yours Wallet Setup

1. Install Yours Wallet extension from Chrome Web Store
2. Create or import a wallet
3. Fund with testnet BSV (for testnet development)

## Contract Development Workflow

```bash
# 1. Edit contract in contracts/*.scrypt.ts

# 2. Compile to generate artifacts
npx scrypt-cli compile

# 3. Test in browser with Yours Wallet
npm run dev
```

## Key Patterns Used

- **ANYONECANPAY_SINGLE** sighash for flexible fee handling
- **Custom tx builder** via `bindTxBuilder()` for full control
- **YoursDirectSigner** for reliable wallet signing
- **Commit-reveal** pattern for hidden moves in games

## Configuration

Copy `.env.example` to `.env`:
- `VITE_BSV_NETWORK` - `testnet` or `mainnet`
- `VITE_ARTIFACT_PATH` - Path to compiled contract artifact

## Deployment

```bash
# Compile contract
npx scrypt-cli compile

# Deploy via the app UI (connects to Yours Wallet)
```

## Troubleshooting

- **"Yours Wallet not detected"** - Install the extension and refresh
- **"outputs mismatch"** - Check that payout output matches contract expectation
- **Vue proxy errors** - Use `toRaw()` when passing contract instances

See `AI_RULES.md` for comprehensive development guidelines.
"#,
        framework, template
    )
}

pub const AI_RULES: &str = r#"# AI Rules for Bitcoin App Development

## sCrypt Smart Contract Rules

### NEVER Import .scrypt.ts Files Directly
```typescript
//  WRONG - This will cause runtime errors
import Contract from "../contracts/Contract.scrypt.ts";
import { RockPaperScissors } from "@/contracts/RockPaperScissors.scrypt.ts";

//  CORRECT - Import compiled artifacts or use dynamic loading
import Contract from "../../contracts/Contract.scrypt";
// Then load artifact dynamically:
const artifact = await fetch("/artifacts/contracts/Contract.scrypt.json");
await Contract.loadArtifact(await artifact.json());
```

### Contract Compilation Workflow
1. Write contract code in `contracts/*.scrypt.ts`
2. Compile with `npx scrypt-cli compile`
3. This generates `artifacts/*.json`
4. Load the artifact dynamically before using the contract

## Architecture & Flow

### Commit-Reveal Pattern
Use commit-reveal for games/auctions where players shouldn't see each other's moves:
1. Both players commit their move hash: `hash256(nonce + move)`
2. Contract is deployed with both commitments (ON-CHAIN)
3. Players share their move+nonce off-chain
4. Either player calls settle() with all moves+nonces
5. Contract verifies commitments ON-CHAIN, determines winner, pays out

### Funding Model
Contract deployer currently funds the full pot. The loser never funds on-chain.
If you need both players to fund, design a two-party funding flow.

## Transaction Building (CRITICAL)

### Use Custom Transaction Builders
The SDK's default tx building can conflict with custom sighash/outputs.
Use `bindTxBuilder()` to control inputs/outputs/change:

```typescript
// Bind BEFORE calling contract method
instance.bindTxBuilder('settle', buildSettleTx);

async function buildSettleTx(
  current: Contract,
  options: MethodCallOptions<Contract>,
  ...methodArgs: any[]
): Promise<ContractTransaction> {
  const unsignedTx = new bsv.Transaction();
  
  // Contract input at index 0
  unsignedTx.addInput(current.buildContractInput());
  
  // Build output 0 - matches contract's expected output
  const script = Utils.buildPublicKeyHashScript(winnerPkh);
  unsignedTx.addOutput(new bsv.Transaction.Output({
    script: bsv.Script.fromHex(script),
    satoshis: current.balance,
  }));
  
  // Manual fee input (wallet UTXO)
  const feeUtxos = await getWalletUtxos();
  unsignedTx.from({
    txId: feeUtxo.txid,
    outputIndex: feeUtxo.vout,
    script: feeUtxo.script,
    satoshis: feeUtxo.satoshis,
  });
  
  // Fee rate + change
  unsignedTx.feePerKb(100);
  unsignedTx.change(options.changeAddress);
  
  return { tx: unsignedTx, atInputIndex: 0, nexts: [] };
}
```

### ANYONECANPAY_SINGLE Sighash
When using `SigHash.ANYONECANPAY_SINGLE`:
- ANYONECANPAY: allows anyone to add inputs (for fees)
- SINGLE: only verifies output at same index as contract input (index 0)
- Keep contract UTXO at input 0, verified payout at output 0
- Fee/change can be at other indices

### Fee Strategy
- Default relay: ~0.5 sat/byte (~500 sat/KB)
- Safe choice: `feePerKb(100)` (100 sat/KB)
- ALWAYS add a change output - without it, providers may merge values
- Manual fee input gives you control; auto-fund may use minimal fees

## Signer Integration

### Use YoursDirectSigner for Settlement
The standard PandaSigner can have proxy bugs. Use YoursDirectSigner:

```typescript
import { getYoursDirectSigner } from "./yoursWalletDirect";

const signer = await getYoursDirectSigner();
await instance.connect(signer);
```

### Why YoursDirectSigner?
- Implements `Signer.getSignatures()` to call wallet's direct API
- Bypasses proxy object issues
- Still uses SDK helpers for script building

## Vue/React Integration

### CRITICAL: Use toRaw() for Vue Reactive Objects
Vue's reactive proxy interferes with scrypt-ts SDK property access.
Always unwrap before passing to contract methods:

```typescript
import { toRaw } from "vue";

//  WRONG - proxy breaks contract
await settleContract(contractInstance.value, params);

//  CORRECT - unwrap the proxy
const rawInstance = toRaw(contractInstance.value);
await settleContract(rawInstance, params);
```

### Avoid Double Wallet Prompts
Don't call explicit `wallet.broadcast()` after contract methods.
Let the provider broadcast after signing - keeps single prompt UX.

## Common Pitfalls

### Provider Auto-Funding Issues
- Can override your fee rate
- May modify outputs if change isn't specified
- Can merge fee value into output 0, breaking payout amounts

### Vue Reactivity Breaks Contracts
- `this.player1` returns undefined through proxy
- Always `toRaw()` contract instances

### Output Mismatch Errors
When "outputs mismatch" appears:
1. Check if SDK merged fee value into output 0
2. Verify payout output hex matches what contract expects
3. Use `Utils.buildPublicKeyHashOutput()` for exact match

### Only Winner Can Settle
In winner-takes-all patterns, only the winner should call settle.
Loser calling settle will fail signature verification.

## Debugging

### Log Transaction Details
```typescript
tx.outputs.forEach((out, i) => {
  console.log(`Output ${i}: ${out.satoshis} sats`);
});
```

### Compare Expected vs Actual
```typescript
const expected = Utils.buildPublicKeyHashOutput(pkh, value);
const actual = tx.outputs[0].toBufferWriter().toBuffer().toString('hex');
console.log("Expected:", expected);
console.log("Actual:", actual);
```

## What Works (Proven Patterns)

 Custom tx builder + ANYONECANPAY_SINGLE + explicit change
 YoursDirectSigner bypassing proxy errors  
 Manual fee input + feePerKb enforced rate
 toRaw() for Vue contract instances
 Single signing prompt (no extra broadcast)

## What Doesn't Work

 Letting provider auto-fund when controlling fee/payout
 Extra wallet.broadcast() (causes second prompt)
 Vue proxies with contract instances
 Assuming SDK default tx building works with custom sighash

## Package Management

### When Adding Imports, Update package.json
```typescript
// If you add this import:
import confetti from "canvas-confetti";

// You MUST also add to package.json:
// "canvas-confetti": "^1.9.0"
```

## Project Structure

### Do Not Run Project Creation Commands
```bash
#  NEVER run these - the project already exists
npx create-vue
npm create vite

#  Only edit existing files
```

### File Organization
- `src/services/contractService.ts` - Contract deployment/settlement
- `src/services/yoursWalletDirect.ts` - Custom signer implementation
- `src/services/pandaSignerService.ts` - SDK signer wrapper
- `src/lib/wallet.ts` - Wallet state utilities
- `contracts/*.scrypt.ts` - Smart contract source
- `artifacts/` - Compiled contract artifacts
"#;
